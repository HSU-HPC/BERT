"C:/Users/Yannis Schumann/Documents/PhD/HierarchyBEs/TreeBasedBatchEffectRemoval/generate_Dataset.R"
)
library(HarmonizR)
options(digits.secs = 6)
#######
features <- 800
batches <- 8
samplesperbatch <- 80
imbalance <- seq(0.1, 0.5, length.out = 3)
mv <- 0.1
core <- 1
adjustment_method <- c("ComBat", "limma")
repetitions <- 10
imb = 0.1
dataset <- generateDataCovariables(features, batches, samplesperbatch, mv, imb)
dataset_nocov <- strip_Covariable(dataset)
dataset_adjusted <- hierarchical_adjustment(dataset, core, method="limma")
dataset_adjusted_nocov <- hierarchical_adjustment(dataset_nocov, core, method="limma")
dataset_adjusted
dataset_adjusted_nocov
compute_asw(dataset_adjusted)
compute_asw(dataset_adjusted_nocov)
source("~/PhD/HierarchyBEs/Study/ParameterStudies/CovariableScaling.R", echo=TRUE)
count_matrix <- matrix(rnbinom(400, size=10, prob=0.1), nrow=50, ncol=8)
batch <- c(rep(1, 4), rep(2, 4))
batch
count_matrix
dim(count_matrix)
count_matrix[1:5, which(batch==2)[1:2]]
count_matrix[1:5, which(batch==2)[1:2]] = NA
count_matrix
group <- rep(c(0,1), 4)
adjusted_counts <- ComBat_seq(count_matrix, batch=batch, group=NULL, full_mod=FALSE)
source("~/PhD/HierarchyBEs/Study/Scaling/strongscaling.R", echo=TRUE)
source("~/PhD/HierarchyBEs/Study/Scaling/strongscaling.R", echo=TRUE)
version
source(
"C:/Users/Yannis Schumann/Documents/PhD/HierarchyBEs/TreeBasedBatchEffectRemoval/hierarchical_adjustment.R"
)
source(
"C:/Users/Yannis Schumann/Documents/PhD/HierarchyBEs/TreeBasedBatchEffectRemoval/generate_Dataset.R"
)
library(HarmonizR)
packageVersion()
sessionInfo()
library("devtools")
devtools::install("C:/Users/Yannis Schumann/Downloads/HarmonizR-HarmonizR-1.1/HarmonizR-HarmonizR-1.1/HarmonizR")
devtools::install("C:/Users/Yannis Schumann/Downloads/HarmonizR-HarmonizR-1.1/HarmonizR-HarmonizR-1.1/HarmonizR")
source("~/PhD/HierarchyBEs/Study/Scaling/strongscaling.R", echo=TRUE)
source("~/PhD/HierarchyBEs/Study/Scaling/strongscaling.R", echo=TRUE)
devtools::install("C:/Users/Yannis Schumann/Documents/PhD/HierarchyBEs/HarmonizR/HarmonizR")
source("~/PhD/HierarchyBEs/Study/Scaling/strongscaling.R", echo=TRUE)
View(dataset_description)
dataset_description[3]
dataset_description[2]
dataset_description[1]
View(dataset_numeric)
View(dataset_numeric)
sapply(dataset_description, class)
sapply(dataset_numeric, class)
as.integer(dataset_description["Batch"])
as.integer(dataset_description["batch"])
as.integer(dataset_description[["batch"]])
dataset_description["batch"] <- as.integer(dataset_description[["batch"]])
sapply(dataset_numeric, class)
sapply(dataset_description, class)
source("~/PhD/HierarchyBEs/Study/Scaling/strongscaling.R", echo=TRUE)
source("C:/Users/Yannis Schumann/Documents/PhD/HierarchyBEs/TreeBasedBatchEffectRemoval/hierarchical_adjustment.R")
source(
"C:/Users/Yannis Schumann/Documents/PhD/HierarchyBEs/TreeBasedBatchEffectRemoval/generate_Dataset.R"
)
library(HarmonizR)
data <- read.csv(file = "C:/Users/Yannis Schumann/Documents/PhD/HierarchyBEs/Data/Petralia/petralia.csv", row.names=1, header=TRUE)
asw_raw = compute_asw(data)
data_adjusted <- data.frame(data);
data_adjusted["Cov_1"] = data_adjusted[["Label"]]
View(data_adjusted)
source("~/PhD/HierarchyBEs/Tests/Petralia/first_test_petralia.R", echo=TRUE)
View(asw_bert_cov)
source("~/PhD/HierarchyBEs/Tests/BRCA/first_test_BRCA.R", echo=TRUE)
View(asw_bert_cov)
data("pbmc_small")
library("seurat")
library(seurat)
source("~/PhD/HierarchyBEs/Tests/Petralia/first_test_petralia.R", echo=TRUE)
asw_limma
source("~/PhD/HierarchyBEs/Tests/BRCA/first_test_BRCA.R", echo=TRUE)
asw_bert
asw_limma
matrix(1,5,1)
matrix(1,5,1)[1]
as.factor(c(1,1,2,2))
batch <- as.factor(c(1,1,2,2))
contrasts(batch)
contr.sum(levels(batch))
contrasts(batch) <- contr.sum(levels(batch))
batch
model.matrix(~batch)
model.matrix(~batch)[,-1,drop=FALSE]
batch <- model.matrix(~batch)[,-1,drop=FALSE]
matrix(1,4,1)
design <- matrix(1,4,1)
cbind(design, batch)
y <- matrix(rnorm(10*9),10,9)
y[,1:3] <- y[,1:3] + 5
batch <- c("A","A","A","B","B","B","C","C","C")
batch <- as.factor(batch)
contrasts(batch) <- contr.sum(levels(batch))
batch <- model.matrix(~batch)[,-1,drop=FALSE]
batch
batch <- as.factor(batch)
contrasts(batch) <- contr.sum(levels(batch))
batch <- model.matrix(~batch)[,-1,drop=FALSE]
batch <- as.factor(batch)
batch
contr.sum(levels(batch))
contrasts(batch) <- contr.sum(levels(batch))
batch
batch <- model.matrix(~batch)[,-1,drop=FALSE]
batch
matrix(1,ncol(y),1)
design <- matrix(1,ncol(y),1)
x
y
lmFit(y, cbind(design, batch))
y <- matrix(rnorm(10*9),10,9)
y[,1:3] <- y[,1:3] + 5
batch <- c("A","A","A","B","B","B","C","C","C")
batch <- as.factor(batch)
contrasts(batch) <- contr.sum(levels(batch))
batch <- model.matrix(~batch)[,-1,drop=FALSE]
batch
lmFit(y, cbind(design, batch))
fit <- lmFit(y, cbind(design, batch))
fit$coefficients
fit$coefficients[, -(1:ncol(matrix(1,ncol(x),1))), drop=FALSE]
fit$coefficients[, -(1:ncol(matrix(1,ncol(y),1))), drop=FALSE]
beta <- fit$coefficients[, -(1:ncol(matrix(1,ncol(y),1))), drop=FALSE]
beta %*% t(batch)
batch <- c("A","A","A","B","B","B","C","C","C")
batch
batch <- as.factor(batch)
batch
contrasts(batch) <- contr.sum(levels(batch))
batch
batch <- model.matrix(~batch)[,-1,drop=FALSE]
batch
batch <- c("A","A","A","B","B","B","C","C","C", "D", "D", "D")
batch <- as.factor(batch)
contrasts(batch) <- contr.sum(levels(batch))
batch <- model.matrix(~batch)[,-1,drop=FALSE]
batch
beta
source("~/PhD/HierarchyBEs/Study/BulkExpression/ovarian_analysis.R", echo=TRUE)
data["Label"]
source("~/PhD/HierarchyBEs/Study/BulkExpression/ovarian_analysis.R", echo=TRUE)
source("~/PhD/HierarchyBEs/Study/RealData/first_test_mouse.R", echo=TRUE)
setwd("~/PhD/HierarchyBEs/Study/RealData")
source("~/PhD/HierarchyBEs/Study/RealData/first_test_mouse.R", echo=TRUE)
source("~/PhD/HierarchyBEs/Study/RealData/first_test_petralia.R", echo=TRUE)
data_adjusted
data_adjusted["Cov_1"]
data <- data_adjusted
logging::loginfo("Formatting Data.")
if(is.matrix(data)){
logging::loginfo("Typecasting input to dataframe.")
data <- data.frame(data)
}
data
logging::loginfo("Replacing NaNs with NAs.")
data <- replace_missing(data)
data
# get names of potential covariables
cov_names <- names(data)[grepl( "Cov" , names( data  ) )]
cat_names <- names(data)[names(data) %in% c("Label", "Batch")]
all_names <- c(cov_names, cat_names)
all_names
if(length(all_names)==1){
if(!is.character(data[1, all_names])){
all_names <- character(0)
}
}else{
dtypes <- sapply(data[, all_names], typeof)
all_names <- all_names[dtypes=="character"]
}
all_names
if (length(all_names>0)){
logging::logwarn(paste("Identified", length(all_names),
"categorical variables among batch, label and all covariates. Note that BERT requires integer values there. Will apply ordinal encoding."))
for(n in all_names){
data[, n] <- ordinal_encode(data[[n]])
}
}
data
logging::loginfo("Removing potential empty rows and columns")
`%>%` <- janitor::`%>%`
data <- data %>% janitor::remove_empty(c("rows", "cols"))
data
# count number of missing values
inital_mvs <- sum(is.na(data))
logging::loginfo(paste("Found ", inital_mvs, " missing values."))
unique_batches <- unique(data[["Batch"]])
unique_batches
mod <- data.frame(data [ , grepl( "Cov" , names( data  ) ) ])
mod
b = 23
data_batch <- data[data["Batch"] == b,]
mod_batch <- mod[data["Batch"] == b,]
mod_batch
dim(mod)[2]==0
get_adjustable_features_with_mod(data_batch, data.frame(mod_batch))
mod_batch
adjustable_batch <- get_adjustable_features_with_mod(data_batch, data.frame(mod_batch))
all(!adjustable_batch)
source("~/PhD/HierarchyBEs/Study/RealData/first_test_petralia.R", echo=TRUE)
data <- data_adjusted
logging::loginfo("Formatting Data.")
if(is.matrix(data)){
logging::loginfo("Typecasting input to dataframe.")
data <- data.frame(data)
}
logging::loginfo("Replacing NaNs with NAs.")
data <- replace_missing(data)
# get names of potential covariables
cov_names <- names(data)[grepl( "Cov" , names( data  ) )]
cat_names <- names(data)[names(data) %in% c("Label", "Batch")]
all_names <- c(cov_names, cat_names)
if(length(all_names)==1){
if(!is.character(data[1, all_names])){
all_names <- character(0)
}
}else{
dtypes <- sapply(data[, all_names], typeof)
all_names <- all_names[dtypes=="character"]
}
if (length(all_names>0)){
logging::logwarn(paste("Identified", length(all_names),
"categorical variables among batch, label and all covariates. Note that BERT requires integer values there. Will apply ordinal encoding."))
for(n in all_names){
data[, n] <- ordinal_encode(data[[n]])
}
}
logging::loginfo("Removing potential empty rows and columns")
`%>%` <- janitor::`%>%`
data <- data %>% janitor::remove_empty(c("rows", "cols"))
# count number of missing values
inital_mvs <- sum(is.na(data))
logging::loginfo(paste("Found ", inital_mvs, " missing values."))
# all unique batch levels
unique_batches <- unique(data[["Batch"]])
# select covariates
mod <- data.frame(data [ , grepl( "Cov" , names( data  ) ) ])
unique_batches
b = 23
data_batch <- data[data["Batch"] == b,]
mod_batch <- mod[data["Batch"] == b,]
adjustable_batch <- get_adjustable_features(data_batch)
all(!adjustable_batch)
data[data["Batch"] == b, !adjustable_batch]
data[data["Batch"] == b, !adjustable_batch] <- NA
for(b in unique_batches){
# data from batch b
data_batch <- data[data["Batch"] == b,]
mod_batch <- mod[data["Batch"] == b,]
# logical with the features that can be adjusted (that is, contain more
# than 2 numeric values in this batch/covariate level)
if(dim(mod)[2]==0){
adjustable_batch <- get_adjustable_features(data_batch)
}else{
adjustable_batch <- get_adjustable_features(data_batch)#get_adjustable_features_with_mod(data_batch, data.frame(mod_batch))
}
# set features from this batch to missing, where adjustable_batch is FALSE
data[data["Batch"] == b, !adjustable_batch] <- NA
}
paste("A",
"B",
"C")
data <- data_adjusted
logging::loginfo("Formatting Data.")
if(is.matrix(data)){
logging::loginfo("Typecasting input to dataframe.")
data <- data.frame(data)
}
logging::loginfo("Replacing NaNs with NAs.")
data <- replace_missing(data)
# get names of potential covariables
cov_names <- names(data)[grepl( "Cov" , names( data  ) )]
cat_names <- names(data)[names(data) %in% c("Label", "Batch")]
all_names <- c(cov_names, cat_names)
if(length(all_names)==1){
if(!is.character(data[1, all_names])){
all_names <- character(0)
}
}else{
dtypes <- sapply(data[, all_names], typeof)
all_names <- all_names[dtypes=="character"]
}
if (length(all_names>0)){
logging::logwarn(paste("Identified", length(all_names),
"categorical variables among batch, label and all covariates. Note that BERT requires integer values there. Will apply ordinal encoding."))
for(n in all_names){
data[, n] <- ordinal_encode(data[[n]])
}
}
logging::loginfo("Removing potential empty rows and columns")
`%>%` <- janitor::`%>%`
data <- data %>% janitor::remove_empty(c("rows", "cols"))
# count number of missing values
inital_mvs <- sum(is.na(data))
logging::loginfo(paste("Found ", inital_mvs, " missing values."))
# all unique batch levels
unique_batches <- unique(data[["Batch"]])
# select covariates
mod <- data.frame(data [ , grepl( "Cov" , names( data  ) ) ])
if(dim(mod)[2]!=0){
logging::loginfo("BERT requires at least 2 numeric values per batch/covariate level. This may reduce the number of adjustable features considerably, depending on the quantification technique.")
}
b = 23
data_batch <- data[data["Batch"] == b,]
mod_batch <- mod[data["Batch"] == b,]
# logical with the features that can be adjusted (that is, contain more
# than 2 numeric values in this batch/covariate level)
if(dim(mod)[2]==0){
adjustable_batch <- get_adjustable_features(data_batch)
}else{
adjustable_batch <- get_adjustable_features_with_mod(data_batch, data.frame(mod_batch))
}
all(!adjustable_batch)
data[data["Batch"] == b, !adjustable_batch]
data[data["Batch"] == b, !adjustable_batch] <- NA
setwd("~/PhD/HierarchyBEs/BERT/BERT")
devtools::load_all()
# load raw data
data <- read.csv(file = "petralia.csv", row.names=1, header=TRUE)
numeric_raw <- count_existing(data)
asw_raw = compute_asw(data)
print(paste("Raw data contains", numeric_raw, "numeric values. ASW Batch=", asw_raw$Batch, ", ASW Label=", asw_raw$Label))
setwd("~/PhD/HierarchyBEs/Study/RealData")
# load raw data
data <- read.csv(file = "petralia.csv", row.names=1, header=TRUE)
numeric_raw <- count_existing(data)
asw_raw = compute_asw(data)
print(paste("Raw data contains", numeric_raw, "numeric values. ASW Batch=", asw_raw$Batch, ", ASW Label=", asw_raw$Label))
# bert + ComBat + covariable
data_adjusted <- data.frame(data);
data_adjusted["Cov_1"] = data_adjusted[["Label"]]
data_adjusted <- hierarchical_adjustment(data_adjusted, 1)
unique_batches
data <- dataset_adjusted
# bert + ComBat + covariable
data_adjusted <- data.frame(data);
data_adjusted["Cov_1"] = data_adjusted[["Label"]]
data <- data_adjusted
logging::loginfo("Formatting Data.")
if(is.matrix(data)){
logging::loginfo("Typecasting input to dataframe.")
data <- data.frame(data)
}
logging::loginfo("Replacing NaNs with NAs.")
data <- replace_missing(data)
# get names of potential covariables
cov_names <- names(data)[grepl( "Cov" , names( data  ) )]
cat_names <- names(data)[names(data) %in% c("Label", "Batch")]
all_names <- c(cov_names, cat_names)
if(length(all_names)==1){
if(!is.character(data[1, all_names])){
all_names <- character(0)
}
}else{
dtypes <- sapply(data[, all_names], typeof)
all_names <- all_names[dtypes=="character"]
}
if (length(all_names>0)){
logging::logwarn(paste("Identified", length(all_names),
"categorical variables among batch, label and all covariates. Note that BERT requires integer values there. Will apply ordinal encoding."))
for(n in all_names){
data[, n] <- ordinal_encode(data[[n]])
}
}
logging::loginfo("Removing potential empty rows and columns")
`%>%` <- janitor::`%>%`
data <- data %>% janitor::remove_empty(c("rows", "cols"))
# count number of missing values
inital_mvs <- sum(is.na(data))
logging::loginfo(paste("Found ", inital_mvs, " missing values."))
# all unique batch levels
unique_batches <- unique(data[["Batch"]])
mod <- data.frame(data [ , grepl( "Cov" , names( data  ) ) ])
mod
if(dim(mod)[2]!=0){
logging::loginfo("BERT requires at least 2 numeric values per batch/covariate level. This may reduce the number of adjustable features considerably, depending on the quantification technique.")
}
unique_batches
b = 21
data_batch <- data[data["Batch"] == b,]
mod_batch <- mod[data["Batch"] == b,]
adjustable_batch <- get_adjustable_features_with_mod(data_batch, data.frame(mod_batch))
adjustable_batch
all(!adjustable_batch)
data[data["Batch"] == b, !adjustable_batch]
data[data["Batch"] == b, !adjustable_batch] <- NA
mod_batch
# load raw data
data <- read.csv(file = "petralia.csv", row.names=1, header=TRUE)
numeric_raw <- count_existing(data)
asw_raw = compute_asw(data)
print(paste("Raw data contains", numeric_raw, "numeric values. ASW Batch=", asw_raw$Batch, ", ASW Label=", asw_raw$Label))
data_adjusted <- data.frame(data);
data_adjusted["Cov_1"] = data_adjusted[["Label"]]
hierarchical_adjustment(data_adjusted, 1)
setwd("~/PhD/HierarchyBEs/BERT/BERT")
devtools::load_all()
setwd("~/PhD/HierarchyBEs/BERT/BERT")
hierarchical_adjustment(data_adjusted, 1)
devtools::load_all()
hierarchical_adjustment(data_adjusted, 1)
devtools::load_all()
hierarchical_adjustment(data_adjusted, 1)
data_adjusted
data_adjusted["Batch"]==21
devtools::load_all()
hierarchical_adjustment(data_adjusted, 1)
devtools::load_all()
hierarchical_adjustment(data_adjusted, 1)
data_adjusted[149,"Batch"]
source("~/PhD/HierarchyBEs/Study/RealData/first_test_petralia.R", echo=TRUE)
setwd("~/PhD/HierarchyBEs/Study/RealData")
source("~/PhD/HierarchyBEs/Study/RealData/first_test_petralia.R", echo=TRUE)
setwd("~/PhD/HierarchyBEs/BERT/BERT")
devtools::load_all()
devtools::install()
devtools::install()
setwd("~/PhD/HierarchyBEs/Study/RealData")
source("~/PhD/HierarchyBEs/Study/RealData/first_test_petralia.R", echo=TRUE)
setwd("~/PhD/HierarchyBEs/Study/RealData")
devtools::load_all()
setwd("~/PhD/HierarchyBEs/BERT/BERT")
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::test()
devtools::load_all()
devtools::test()
mat <- matrix(rnorm(5*5), nrow=5, ncol=5)
mat <- data.frame(mat)
mat["Batch"] <- c(1,1,1,1,1)
mat["Cov_1"] <- c(1,2,2,2,2)
mod <- data.frame(mat [ , grepl( "Cov" , names( mat  ) ) ])
mat <- mat [ , !grepl( "Cov" , names( mat  ) ) ]
#expect_error(get_adjustable_features_with_mod(mat, mod), "Don't have enough samples from batch/covariate level.")
mat["Batch"] <- c(1,2,2,2,2)
mat
mat <- matrix(rnorm(5*5), nrow=5, ncol=5)
mat <- data.frame(mat)
mat["Batch"] <- c(1,1,1,1,1)
mat["Cov_1"] <- c(1,2,2,2,2)
mod <- data.frame(mat [ , grepl( "Cov" , names( mat  ) ) ])
mat <- mat [ , !grepl( "Cov" , names( mat  ) ) ]
mat
get_adjustable_features_with_mod(mat, mod)
mat <- matrix(rnorm(1*5), nrow=1, ncol=5)
mat <- data.frame(mat)
mat["Batch"] <- c(1)
get_adjustable_features(mat)
testthat::expect_error(stop("Test"))
testthat::expect_error(stop("Test"), "Test")
devtools::load_all()
testthat::expect_error(stop("Test"), "Test")
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
mat <- matrix(rnorm(1*5), nrow=1, ncol=5)
mat <- data.frame(mat)
mat["Batch"] <- c(1)
data_batch <- mat
available_data <- !is.na(data_batch)
# add the booleans per column (per feature)--> counts of numeric values
available_data <- colSums(available_data)
# Batch column should be adjustable at least. If not, that means that we
# don't have enough samples at this batch/covariable level
available_data[["Batch"]]<=1
available_data[1, ["Batch"]]<=1
available_data[1, "Batch"]<=1
stop("Don't have enough samples from batch/covariate level.")
devtools::load_all()
devtools::test()
mat <- matrix(rnorm(1*5), nrow=1, ncol=5)
mat <- data.frame(mat)
mat["Batch"] <- c(1)
expect_error(get_adjustable_features(mat))
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
setwd("~/PhD/HierarchyBEs/Study/RealData")
source("~/PhD/HierarchyBEs/Study/RealData/first_test_petralia.R", echo=TRUE)
setwd("~/PhD/HierarchyBEs/BERT/BERT")
devtools::install()
source("~/PhD/HierarchyBEs/Study/ParameterStudies/CovariableScaling.R", echo=TRUE)
setwd("~/PhD/HierarchyBEs/BERT/BERT")
devtools::install()
